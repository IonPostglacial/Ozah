LIBRARY POLICY: Minimize external dependencies. Backend should use Go standard library and golang.org/x packages only.
Frontend can use small, standalone libraries (JS/CSS files) that work without build tools/npm.

FRONTEND POLICY: Progressive enhancement - app must work (potentially degraded) with JavaScript disabled.
- htmx is our only JavaScript dependency (for AJAX requests, partial updates, hx-boost)
- Use Go templates for pseudo-components (reusable template blocks)
- Use custom elements (web components) for interactive features
- Leverage modern CSS (grid, flexbox, :has(), container queries, etc.) for layout and interactivity
- JavaScript should enhance, not enable - core functionality must work without it
- Forms use POST/GET actions, buttons trigger server-side handlers via action system
- JS/htmx adds polish: client-side validation, dynamic updates, animations, partial page updates, etc.

ACTION SYSTEM: The action registry pattern is used for handling form submissions to avoid big switch statements.
- Create an Actions struct (e.g., `MenuActions`, `PanelActions`, `AdminActions`) holding `cc *common.Context`
- Implement action methods that check for their button name: `if r.PostFormValue("button-name") == "" { return nil }`
- Register actions via `Register(reg *action.Registry)` method by calling `reg.AppendAction(action.Action(h.methodName))`
- In handlers: call `cc.RegisterActions(NewMyActions(cc))` then `cc.ExecuteActions(ctx, r)`
- HTML: use named submit buttons `<button type="submit" name="action-name" value="arg">` not hidden action fields
- See `server/action/handler.go` for helpers: `NewActionWithIntArgument`, `NewActionWithStringArgument`, `NewActionWithFileUpload`

HTML CONVENTIONS:
- Use `{{ template "page_head" . }}` for consistent head section (includes all CSS/JS)
- Use existing CSS classes: `.btn-group`, `.hbox`, `.vbox`, `.padded`, `.separated-bottom`, `.vertical-align`, etc.
- For conceptual components: use custom elements with `hazo-` prefix (e.g., `<hazo-capability-badge>`, `<hazo-popover>`) rather than classes
- For icons: use FontAwesome classes `<i class="fa-solid fa-icon-name"></i>` (e.g., `fa-plus`, `fa-close`, `fa-trash`, `fa-maximize`)
- Avoid inline styles (`style="..."`); use CSS classes, custom element selectors, or add minimal `<style>` block using CSS variables
- CSS variables to reuse: `--widget-radius`, `--widget-padding`, `--widget-border-width`, `--widget-border-color`, `--widget-bg-color`, `--bg-color-primary`, `--text-color-primary`
- Forms: progressive enhancement - work without JS, use htmx for enhancements
- Use semantic HTML: `<details>/<summary>` for collapsible sections, `<table>` with `<thead>`/`<tbody>` for data
- See `server/views/taxons/taxons.html` for comprehensive layout examples and `server/components/` for custom element patterns

COMPONENT SYSTEM: Custom elements should have their CSS/JS in the components folder for automatic aggregation.
- Component files live in `server/components/{componentname}/` directory
- CSS files: `{componentname}.css` - automatically aggregated into single CSS bundle via `components/init.go`
- JS files: `{componentname}.js` - automatically aggregated and wrapped in IIFE via `components/init.go`
- HTML templates: `{componentname}.html` - define Go template blocks with `{{ define "name" }}`
- Go files: `{componentname}.go` - handler logic, template data structs
- All `.css` and `.js` files in `server/components/*/` are embedded at build time and served as single files
- Custom elements use `hazo-` prefix: `<hazo-popover>`, `<hazo-capability-badge>`, `<hazo-tree-menu>`
- Style custom elements with element selectors, not classes: `hazo-popover { ... }` not `.popover { ... }`
- Generic utility styles (e.g., `.inline`, `.message-error`, `.danger`) go in `server/assets/style.css`, not component CSS
- See `server/components/init.go` for the aggregation mechanism and existing components for structure examples

# Dataset Import API
Currently dataset import exists via /upload form endpoint and CLI commands.
Need proper API endpoints for programmatic access.
- [x] Create API endpoint POST /api/datasets/json for JSON dataset uploads (cookie authentication)
- [x] Create API endpoint POST /api/datasets/csv for CSV dataset uploads (cookie authentication)
- [x] In case of error, instead of a file, both API endpoints should return structured JSON responses with success/error details
- [x] Maintain existing /upload form endpoint for no-JS HTML form submission
- [x] Add API documentation for dataset import endpoints
- [x] Add validation and proper error responses for API calls

# Dataset Export API
Currently dataset export exists via CLI command (hazo exportjson) and /export form endpoint.
Need proper API endpoints for programmatic access following the existing export patterns.
- [x] Create API endpoint GET /api/datasets/{name}/json for JSON dataset downloads (cookie authentication)
- [x] Reuse existing export/hazojson.go logic for dataset serialization
- [x] Return proper JSON content-type headers and structured error responses
- [x] Implement access control: users can only export datasets they own or have been shared with them
- [ ] Support optional query parameters for export customization (e.g., ?include_pictures=true)
- [x] Add proper error handling for missing datasets or unauthorized access
- [x] Maintain existing /export form endpoint for browser downloads
- [ ] Add API documentation for dataset export endpoint
- [x] Consider adding CSV export API endpoint GET /api/datasets/{name}/csv for consistency

# Import pictures
Picture upload UI exists but backend functionality is incomplete.
Need CLI command, form action endpoint (no JS), and API endpoint.
Following the existing action pattern (see panelActions.go, action/handler.go).

Backend:
- [x] Implement thumbnail generation using Go standard library (image, image/jpeg, image/png packages) - decode, resize, encode
- [x] Store thumbnails in user's private directory with naming convention (e.g., {docRef}_{index}_{size}.jpg)
- [x] Create CLI command to add picture to dataset with thumbnail generation (hazo addpicture -dataset <name> -ref <id> -file <path> [-index <n>])
- [x] Create pictureActions.go following panelActions.go pattern with uploadPicture action
- [x] Add action.NewActionWithFileUpload() helper in action/handler.go to handle multipart/form-data
- [x] Register picture actions in appropriate handler (taxons, characters) using cc.RegisterActions()
- [x] Create picture serving endpoint GET /ds/{dsName}/pictures/{docRef}/{index}?size=small|medium|big
- [x] Implement access control: user can access own pictures + pictures from datasets shared with them
- [x] Create API endpoint POST /api/pictures for programmatic uploads (cookie authentication) with JSON response

# Administration Interface - Capability System
Need admin interface for user management. Using a capability-based permission system for flexibility and principle of least privilege.

## Design
- Capability-based permissions allow fine-grained control (e.g., user.manage, dataset.admin, system.configure)
- Consistent with existing dataset sharing permission model
- Each capability can be granted to specific users with audit trail
- Easier to extend with new admin functions without schema changes

## Schema Changes
- [x] Create Capability table in app schema (Name primary key, Description)
- [x] Create User_Capability table (User_Login, Capability_Name, Granted_Date, Granted_By)
- [x] Pre-populate standard capabilities:
      - 'user.manage': Create, modify, and delete user accounts
      - 'system.configure': Modify system-wide configuration  
      - 'dataset.admin': Access and manage all datasets
- [x] Create migration to add capability tables to existing databases

## Backend Implementation
- [x] Update storage/app/queries.sql with capability management queries:
      - GetUserCapabilities(login)
      - GrantUserCapability(login, capability, grantedBy)
      - RevokeUserCapability(login, capability)
      - ListUsersWithCapability(capability)
      - GetAllUsers() - for admin interface
      - GetAllCapabilities() - for dropdown selection
      - GetAllUsersWithCapabilities() - joined query for efficient user/capability display
- [x] Run sqlc generate to create Go code
- [x] Update adduser command to support optional -capabilities flag (comma-separated list)
- [x] Create capability middleware function to protect routes by required capability
- [x] Create admin helper functions in user package to check capabilities

## Admin Interface
- [x] Create admin interface route/handler (e.g., /admin) protected by 'user.manage' capability (using the RequireCapability handlerwrapper)
- [x] Build admin user list view showing all users with their capabilities
- [x] Add "Add User" functionality in admin interface
- [x] Add "Delete User" functionality with confirmation
- [x] Add "Grant Capability" functionality with dropdown of available capabilities
- [x] Add "Revoke Capability" functionality 
- [x] Add visual indication of user capabilities in UI (badges/tags)
- [x] Show audit trail (who granted capabilities and when)

# Microsoft Account Authentication
Support MS account login alongside local authentication.
Note: Implement OAuth2 using Go stdlib (net/http, crypto) and golang.org/x packages if needed. Avoid MSAL.
- [ ] Implement OAuth2 flow for Microsoft login using Go stdlib (net/http for requests, encoding/json for parsing)
- [ ] Use golang.org/x/oauth2 if necessary (acceptable as x-repo), otherwise implement OAuth2 manually
- [ ] Add MS_Account_Id column to Credentials table
- [ ] Create MS_Account_Requests table for pending access requests
- [ ] Create "Login with Microsoft" button on login page
- [ ] Store MS account ID when user authenticates
- [ ] Create pending requests view for admins
- [ ] Allow admins to approve/reject MS account access requests
- [ ] Link approved MS accounts to existing or new user accounts
- [ ] Handle MS account session management and token refresh

Bulk photo download/thumbnail generation:
- [ ] Create CLI command to bulk download/process pictures for a dataset (hazo syncpictures -dataset <name>)
- [ ] For each Document_Attachment record with a Source URL:
  - If image file doesn't exist locally: download from Source URL with per-domain rate limiting
  - If image exists locally but thumbnails are missing: generate thumbnails from local file
  - If both exist: skip (idempotent operation)
- [ ] Use asynchronous/concurrent downloads with worker pool pattern
- [ ] Implement per-domain rate limiting to avoid overwhelming source servers (polite crawling)
- [ ] Log progress and any download/generation failures
- [ ] Support optional flags: -force (redownload/regenerate all), -dry-run (show what would be done)

Frontend (No JavaScript):
- [ ] Update picturebox.html to wrap upload button in a form with method="POST" enctype="multipart/form-data"
- [ ] Add hidden inputs for entity type and ref ID to the form
- [ ] Change upload button to submit type with name="picture-upload" (matching action registration)
- [ ] Add file input with name="picture-file" (styled with CSS if needed)
- [ ] Form will POST to current page URL, action system will handle it via ExecuteActions()
- [ ] After successful upload, page reload will show new picture (following existing pattern)

# Picture Display with Thumbnails
Pictures should use thumbnails of appropriate sizes, not full-size images.
- [ ] Update picture upload to automatically generate thumbnails (small, medium, big) on import
- [ ] Modify picturebox component to request appropriate thumbnail size
- [ ] Use small thumbnails for icon displays and grids
- [ ] Use medium thumbnails for normal detail views
- [ ] Use big thumbnails or original for zoomed/fullscreen view
- [ ] Update picture serving endpoint to serve correct size based on request

# Dataset Editing Capabilities
Currently can only import and visualize datasets, need ability to edit them.
Note: INSERT operations already exist in queries.sql (created for import command) but should be moved to command.sql for consistency.
- [ ] Create command.sql file for edit operations (UPDATE, DELETE for taxons, characters, states, etc.)
- [ ] Move existing INSERT operations from queries.sql to command.sql (InsertDocument, InsertLang, InsertDocumentTranslation, InsertDocumentAttachment, InsertUnit, InsertBook, InsertState, InsertCategoricalCharacter, InsertMeasurementCharacter, InsertPeriodicCharacter, InsertGeographicalPlace, InsertTaxon, InsertTaxonDescription, InsertTaxonMeasurement, etc.)
- [ ] Update sqlc.yaml configuration to include command.sql for code generation
- [ ] Generate Go functions from command.sql using sqlc
- [ ] Create edit mode UI for taxons (add/edit/delete taxons)
- [ ] Create edit mode UI for characters (add/edit/delete characters)
- [ ] Create edit mode UI for states (add/edit/delete states)
- [ ] Create edit mode UI for measurements (add/edit/delete measurements)
- [ ] Add save/cancel functionality with proper error handling
- [ ] Implement validation for edited data
- [ ] Add confirmation dialogs for destructive operations (delete)

# Display Calendars
Calendar data structure exists in imports but no display implementation.
- [ ] Create SQL query to retrieve calendar/periodic data for a taxon
- [ ] Create calendar display component (Go viewmodel + HTML template)
- [ ] Add calendar section to appropriate views (taxons/characters)
- [ ] Style calendar display appropriately

# Display Geographical Data (PRIORITY)
Display geographical characters/states as colored features on a map.
Some characters and states are geographical in nature (e.g., distribution ranges, habitat regions).
Need to display these as GeoJSON shapes/features on a map in taxon state edition/visualization views.
Note: Frontend map library (Leaflet/OpenLayers) is acceptable as it's browser-side. Backend should use Go stdlib only.
- [ ] Choose lightweight frontend map library for displaying GeoJSON shapes (Leaflet recommended - small, no build step)
- [ ] Add map library assets (single JS/CSS files, no npm dependencies)
- [ ] Create map component for geographical characters (Go viewmodel + HTML template/custom component)
- [ ] Create SQL query to retrieve geographical character/state data (GeoJSON) for a taxon
- [ ] Implement map rendering with colored features representing different geographical states
- [ ] Add map to character/state visualization views
- [ ] Add map to character/state editing views with ability to modify GeoJSON shapes
- [ ] Style geographical states with distinct colors on the map
- [ ] Add legend showing which states correspond to which colored regions

# Display Taxon Specimen Locations (Nice to Have)
Display collection/observation locations of taxon specimens on a map.
This is separate from geographical characters - these are point locations where specimens were found.
- [ ] Extend database schema to store specimen location data (lat/lon coordinates)
- [ ] Create SQL query to retrieve specimen locations for a taxon
- [ ] Create specimen map component (can reuse map library from geographical data feature)
- [ ] Display specimen locations as markers/points on map
- [ ] Add popup/tooltip for each specimen showing collection details
- [ ] Add specimen map view to taxon detail pages
- [ ] Consider clustering for many specimens in same area

# Display measurements in Summary
Summary component exists but doesn't show measurements.
- [ ] Create SQL query to retrieve taxon measurements (from Taxon_Measurement table)
- [ ] Extend summary viewmodel to include measurements
- [ ] Update summary.html template to display measurements (min/max ranges, units)
- [ ] Style measurement display appropriately

# Display measurements in Descriptors
Descriptors panel doesn't show measurements.
- [ ] Create/extend SQL query to retrieve measurements alongside categorical descriptors
- [ ] Extend descriptors viewmodel to include measurement data
- [ ] Update descriptors display to show measurement ranges with units
- [ ] Add filtering capability for measurements in descriptor search