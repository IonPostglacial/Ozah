// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package dsdb

import (
	"context"
	"database/sql"
	"strings"
)

const deleteDocumentAttachment = `-- name: DeleteDocumentAttachment :exec
delete from Document_Attachment 
where Document_Ref = ? and Attachment_Index = ?
`

type DeleteDocumentAttachmentParams struct {
	DocumentRef     string
	AttachmentIndex int64
}

func (q *Queries) DeleteDocumentAttachment(ctx context.Context, arg DeleteDocumentAttachmentParams) error {
	_, err := q.db.ExecContext(ctx, deleteDocumentAttachment, arg.DocumentRef, arg.AttachmentIndex)
	return err
}

const distinctiveCharacters = `-- name: DistinctiveCharacters :many
select ch.Ref, ch.Name, s.Ref State_ref, s.Name State_Name from Document ch
inner join Document s on s.Path = (ch.Path || '.' || ch.Ref)
where (ch.Path || '.' || ch.Ref) in (
    select doc.Path from Document doc 
    where Ref in (
        select Description_Ref from Taxon_Description 
        group by Description_ref 
        order by count(Taxon_Ref)
    )
)
`

type DistinctiveCharactersRow struct {
	Ref       string
	Name      string
	StateRef  string
	StateName string
}

func (q *Queries) DistinctiveCharacters(ctx context.Context) ([]DistinctiveCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, distinctiveCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DistinctiveCharactersRow
	for rows.Next() {
		var i DistinctiveCharactersRow
		if err := rows.Scan(
			&i.Ref,
			&i.Name,
			&i.StateRef,
			&i.StateName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStates = `-- name: GetAllStates :many
select doc.Ref, doc.Path, doc.Name, doc.Details, tr1.name name_tr1, tr2.name name_tr2, s.Color from Document doc
left join Document_Translation tr1 on doc.Ref = tr1.Document_Ref and tr1.Lang_Ref = "EN"
left join Document_Translation tr2 on doc.Ref = tr2.Document_Ref and tr2.Lang_Ref = "CN"
inner join State s on doc.Ref = s.Document_Ref
order by doc.Path asc, doc.Doc_Order asc
`

type GetAllStatesRow struct {
	Ref     string
	Path    string
	Name    string
	Details sql.NullString
	NameTr1 sql.NullString
	NameTr2 sql.NullString
	Color   sql.NullString
}

func (q *Queries) GetAllStates(ctx context.Context) ([]GetAllStatesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllStates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllStatesRow
	for rows.Next() {
		var i GetAllStatesRow
		if err := rows.Scan(
			&i.Ref,
			&i.Path,
			&i.Name,
			&i.Details,
			&i.NameTr1,
			&i.NameTr2,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTaxonsWithTranslations = `-- name: GetAllTaxonsWithTranslations :many
select t.document_ref, t.author, t.website, t.meaning, t.herbarium_no, t.herbarium_picture, t.fasc, t.page, doc.ref, doc.path, doc.doc_order, doc.name, doc.details, tr1.name name_v, tr2.name name_cn from Taxon t
inner join Document doc on doc.Ref = t.Document_Ref
left join Document_Translation tr1 on doc.Ref = tr1.Document_Ref and tr1.Lang_Ref = "V"
left join Document_Translation tr2 on doc.Ref = tr2.Document_Ref and tr2.Lang_Ref = "CN"
order by doc.Path asc, doc.Doc_Order asc
`

type GetAllTaxonsWithTranslationsRow struct {
	DocumentRef      string
	Author           string
	Website          sql.NullString
	Meaning          sql.NullString
	HerbariumNo      sql.NullString
	HerbariumPicture sql.NullString
	Fasc             sql.NullInt64
	Page             sql.NullInt64
	Ref              string
	Path             string
	DocOrder         int64
	Name             string
	Details          sql.NullString
	NameV            sql.NullString
	NameCn           sql.NullString
}

func (q *Queries) GetAllTaxonsWithTranslations(ctx context.Context) ([]GetAllTaxonsWithTranslationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllTaxonsWithTranslations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTaxonsWithTranslationsRow
	for rows.Next() {
		var i GetAllTaxonsWithTranslationsRow
		if err := rows.Scan(
			&i.DocumentRef,
			&i.Author,
			&i.Website,
			&i.Meaning,
			&i.HerbariumNo,
			&i.HerbariumPicture,
			&i.Fasc,
			&i.Page,
			&i.Ref,
			&i.Path,
			&i.DocOrder,
			&i.Name,
			&i.Details,
			&i.NameV,
			&i.NameCn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBooks = `-- name: GetBooks :many
select doc.Ref, doc.Path, doc.Name, tr1.name name_tr1, tr2.name name_tr2, b.ISBN from Document doc
left join Document_Translation tr1 on doc.Ref = tr1.Document_Ref and tr1.Lang_Ref = "EN"
left join Document_Translation tr2 on doc.Ref = tr2.Document_Ref and tr2.Lang_Ref = "CN"
inner join Book b on doc.Ref = b.Document_Ref
order by doc.Path asc, doc.Doc_Order asc
`

type GetBooksRow struct {
	Ref     string
	Path    string
	Name    string
	NameTr1 sql.NullString
	NameTr2 sql.NullString
	Isbn    sql.NullString
}

func (q *Queries) GetBooks(ctx context.Context) ([]GetBooksRow, error) {
	rows, err := q.db.QueryContext(ctx, getBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBooksRow
	for rows.Next() {
		var i GetBooksRow
		if err := rows.Scan(
			&i.Ref,
			&i.Path,
			&i.Name,
			&i.NameTr1,
			&i.NameTr2,
			&i.Isbn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCatCharactersNameTr2 = `-- name: GetCatCharactersNameTr2 :many
select doc.Ref, doc.Path, doc.Name, tr1.name name_tr1, tr2.name name_tr2, ch.Color from Document doc 
left join Document_Translation tr1 on doc.Ref = tr1.Document_Ref and tr1.Lang_Ref = ?1
left join Document_Translation tr2 on doc.Ref = tr2.Document_Ref and tr2.Lang_Ref = ?2
left join Categorical_Character ch on doc.Ref = ch.Document_Ref
where doc.Ref in (/*SLICE:refs*/?)
order by doc.Path, Doc_Order asc
`

type GetCatCharactersNameTr2Params struct {
	Lang1 string
	Lang2 string
	Refs  []string
}

type GetCatCharactersNameTr2Row struct {
	Ref     string
	Path    string
	Name    string
	NameTr1 sql.NullString
	NameTr2 sql.NullString
	Color   sql.NullString
}

func (q *Queries) GetCatCharactersNameTr2(ctx context.Context, arg GetCatCharactersNameTr2Params) ([]GetCatCharactersNameTr2Row, error) {
	query := getCatCharactersNameTr2
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Lang1)
	queryParams = append(queryParams, arg.Lang2)
	if len(arg.Refs) > 0 {
		for _, v := range arg.Refs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:refs*/?", strings.Repeat(",?", len(arg.Refs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:refs*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCatCharactersNameTr2Row
	for rows.Next() {
		var i GetCatCharactersNameTr2Row
		if err := rows.Scan(
			&i.Ref,
			&i.Path,
			&i.Name,
			&i.NameTr1,
			&i.NameTr2,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoricalCharacters = `-- name: GetCategoricalCharacters :many
select doc.Ref, doc.Path, doc.Details, doc.Name, tr1.name name_tr1, tr2.name name_tr2, ch.Color from Categorical_Character ch
inner join Document doc on doc.Ref = ch.Document_Ref
left join Document_Translation tr1 on doc.Ref = tr1.Document_Ref and tr1.Lang_Ref = "EN"
left join Document_Translation tr2 on doc.Ref = tr2.Document_Ref and tr2.Lang_Ref = "CN"
order by doc.Name
`

type GetCategoricalCharactersRow struct {
	Ref     string
	Path    string
	Details sql.NullString
	Name    string
	NameTr1 sql.NullString
	NameTr2 sql.NullString
	Color   sql.NullString
}

func (q *Queries) GetCategoricalCharacters(ctx context.Context) ([]GetCategoricalCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategoricalCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoricalCharactersRow
	for rows.Next() {
		var i GetCategoricalCharactersRow
		if err := rows.Scan(
			&i.Ref,
			&i.Path,
			&i.Details,
			&i.Name,
			&i.NameTr1,
			&i.NameTr2,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCharacterStates = `-- name: GetCharacterStates :many
select s.Document_Ref from State s
inner join Document doc on doc.Ref = s.Document_Ref
inner join Document ch on (ch.Path || '.' || ch.Ref) = doc.Path
where ch.Ref = ?
`

func (q *Queries) GetCharacterStates(ctx context.Context, ref string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCharacterStates, ref)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var document_ref string
		if err := rows.Scan(&document_ref); err != nil {
			return nil, err
		}
		items = append(items, document_ref)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDescriptors = `-- name: GetDescriptors :many
select 
    doc.Ref, doc.Path, doc.Name, doc.Details, 
    att.Source, (descriptor.Taxon_Ref is null) Unselected, 
    tr1.name name_tr1, tr2.name name_tr2 
from Document doc 
left join Document_Translation tr1 on doc.Ref = tr1.Document_Ref and tr1.Lang_Ref = "EN"
left join Document_Translation tr2 on doc.Ref = tr2.Document_Ref and tr2.Lang_Ref = "CN"
left join Document_Attachment att on doc.Ref = att.Document_Ref
left join Taxon_Description descriptor on doc.Ref = descriptor.Description_Ref
where (doc.Path = ? and (descriptor.Taxon_Ref is null or descriptor.Taxon_Ref = ?))
order by doc.Path asc, Doc_Order asc
`

type GetDescriptorsParams struct {
	Path     string
	TaxonRef string
}

type GetDescriptorsRow struct {
	Ref        string
	Path       string
	Name       string
	Details    sql.NullString
	Source     sql.NullString
	Unselected interface{}
	NameTr1    sql.NullString
	NameTr2    sql.NullString
}

func (q *Queries) GetDescriptors(ctx context.Context, arg GetDescriptorsParams) ([]GetDescriptorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDescriptors, arg.Path, arg.TaxonRef)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDescriptorsRow
	for rows.Next() {
		var i GetDescriptorsRow
		if err := rows.Scan(
			&i.Ref,
			&i.Path,
			&i.Name,
			&i.Details,
			&i.Source,
			&i.Unselected,
			&i.NameTr1,
			&i.NameTr2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocument = `-- name: GetDocument :one
select ref, path, doc_order, name, details from Document doc where (doc.Ref = ?)
`

func (q *Queries) GetDocument(ctx context.Context, ref string) (Document, error) {
	row := q.db.QueryRowContext(ctx, getDocument, ref)
	var i Document
	err := row.Scan(
		&i.Ref,
		&i.Path,
		&i.DocOrder,
		&i.Name,
		&i.Details,
	)
	return i, err
}

const getDocumentAttachmentByIndex = `-- name: GetDocumentAttachmentByIndex :one
select document_ref, attachment_index, source, path, path_small, path_medium, path_big from Document_Attachment 
where Document_Ref = ? and Attachment_Index = ?
`

type GetDocumentAttachmentByIndexParams struct {
	DocumentRef     string
	AttachmentIndex int64
}

func (q *Queries) GetDocumentAttachmentByIndex(ctx context.Context, arg GetDocumentAttachmentByIndexParams) (DocumentAttachment, error) {
	row := q.db.QueryRowContext(ctx, getDocumentAttachmentByIndex, arg.DocumentRef, arg.AttachmentIndex)
	var i DocumentAttachment
	err := row.Scan(
		&i.DocumentRef,
		&i.AttachmentIndex,
		&i.Source,
		&i.Path,
		&i.PathSmall,
		&i.PathMedium,
		&i.PathBig,
	)
	return i, err
}

const getDocumentAttachments = `-- name: GetDocumentAttachments :many
select document_ref, attachment_index, source, path, path_small, path_medium, path_big from Document_Attachment att 
where (att.Document_Ref = ?)
`

func (q *Queries) GetDocumentAttachments(ctx context.Context, documentRef string) ([]DocumentAttachment, error) {
	rows, err := q.db.QueryContext(ctx, getDocumentAttachments, documentRef)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentAttachment
	for rows.Next() {
		var i DocumentAttachment
		if err := rows.Scan(
			&i.DocumentRef,
			&i.AttachmentIndex,
			&i.Source,
			&i.Path,
			&i.PathSmall,
			&i.PathMedium,
			&i.PathBig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentDirectChildren = `-- name: GetDocumentDirectChildren :many
select ref, path, doc_order, name, details from Document doc 
where (doc.Path = ?)
order by Path asc, Doc_Order asc
`

func (q *Queries) GetDocumentDirectChildren(ctx context.Context, path string) ([]Document, error) {
	rows, err := q.db.QueryContext(ctx, getDocumentDirectChildren, path)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Document
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.Ref,
			&i.Path,
			&i.DocOrder,
			&i.Name,
			&i.Details,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentDirectChildrenRefs = `-- name: GetDocumentDirectChildrenRefs :many
select Ref from Document doc 
where (doc.Path = ?)
order by Path asc, Doc_Order asc
`

func (q *Queries) GetDocumentDirectChildrenRefs(ctx context.Context, path string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDocumentDirectChildrenRefs, path)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var ref string
		if err := rows.Scan(&ref); err != nil {
			return nil, err
		}
		items = append(items, ref)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentTr2 = `-- name: GetDocumentTr2 :one
select doc.ref, doc.path, doc.doc_order, doc.name, doc.details, tr1.name name_tr1, tr2.name name_tr2 from Document doc
left join Document_Translation tr1 on doc.Ref = tr1.Document_Ref and tr1.Lang_Ref = ?1
left join Document_Translation tr2 on doc.Ref = tr2.Document_Ref and tr2.Lang_Ref = ?2
where (doc.Ref = ?3)
`

type GetDocumentTr2Params struct {
	Lang1 string
	Lang2 string
	Ref   string
}

type GetDocumentTr2Row struct {
	Ref      string
	Path     string
	DocOrder int64
	Name     string
	Details  sql.NullString
	NameTr1  sql.NullString
	NameTr2  sql.NullString
}

func (q *Queries) GetDocumentTr2(ctx context.Context, arg GetDocumentTr2Params) (GetDocumentTr2Row, error) {
	row := q.db.QueryRowContext(ctx, getDocumentTr2, arg.Lang1, arg.Lang2, arg.Ref)
	var i GetDocumentTr2Row
	err := row.Scan(
		&i.Ref,
		&i.Path,
		&i.DocOrder,
		&i.Name,
		&i.Details,
		&i.NameTr1,
		&i.NameTr2,
	)
	return i, err
}

const getDocumentsAndParentsNames = `-- name: GetDocumentsAndParentsNames :many
select parent.Ref Parent_Ref, parent.Name Parent_Name, doc.Ref, doc.Name from Document doc
left join Document parent on doc.Path = (parent.Path || '.' || parent.Ref)
where doc.Ref in (/*SLICE:refs*/?)
order by parent.Ref, doc.Doc_Order
`

type GetDocumentsAndParentsNamesRow struct {
	ParentRef  sql.NullString
	ParentName sql.NullString
	Ref        string
	Name       string
}

func (q *Queries) GetDocumentsAndParentsNames(ctx context.Context, refs []string) ([]GetDocumentsAndParentsNamesRow, error) {
	query := getDocumentsAndParentsNames
	var queryParams []interface{}
	if len(refs) > 0 {
		for _, v := range refs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:refs*/?", strings.Repeat(",?", len(refs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:refs*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentsAndParentsNamesRow
	for rows.Next() {
		var i GetDocumentsAndParentsNamesRow
		if err := rows.Scan(
			&i.ParentRef,
			&i.ParentName,
			&i.Ref,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentsNames = `-- name: GetDocumentsNames :many
select Ref, Name from Document doc 
where doc.Ref in (/*SLICE:refs*/?)
order by doc.Path
`

type GetDocumentsNamesRow struct {
	Ref  string
	Name string
}

func (q *Queries) GetDocumentsNames(ctx context.Context, refs []string) ([]GetDocumentsNamesRow, error) {
	query := getDocumentsNames
	var queryParams []interface{}
	if len(refs) > 0 {
		for _, v := range refs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:refs*/?", strings.Repeat(",?", len(refs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:refs*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentsNamesRow
	for rows.Next() {
		var i GetDocumentsNamesRow
		if err := rows.Scan(&i.Ref, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeasurementCharacters = `-- name: GetMeasurementCharacters :many
select doc.Ref, doc.Name, mc.Unit_Ref from Measurement_Character mc
inner join Document doc on doc.Ref = mc.Document_Ref
order by doc.Name
`

type GetMeasurementCharactersRow struct {
	Ref     string
	Name    string
	UnitRef sql.NullString
}

func (q *Queries) GetMeasurementCharacters(ctx context.Context) ([]GetMeasurementCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, getMeasurementCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMeasurementCharactersRow
	for rows.Next() {
		var i GetMeasurementCharactersRow
		if err := rows.Scan(&i.Ref, &i.Name, &i.UnitRef); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeasurementCharactersWithTranslations = `-- name: GetMeasurementCharactersWithTranslations :many
select doc.Ref, doc.Path, doc.Name, doc.Details, mc.Unit_Ref, tr1.name name_tr1, tr2.name name_tr2 from Measurement_Character mc
inner join Document doc on doc.Ref = mc.Document_Ref
left join Document_Translation tr1 on doc.Ref = tr1.Document_Ref and tr1.Lang_Ref = "EN"
left join Document_Translation tr2 on doc.Ref = tr2.Document_Ref and tr2.Lang_Ref = "CN"
order by doc.Name
`

type GetMeasurementCharactersWithTranslationsRow struct {
	Ref     string
	Path    string
	Name    string
	Details sql.NullString
	UnitRef sql.NullString
	NameTr1 sql.NullString
	NameTr2 sql.NullString
}

func (q *Queries) GetMeasurementCharactersWithTranslations(ctx context.Context) ([]GetMeasurementCharactersWithTranslationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMeasurementCharactersWithTranslations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMeasurementCharactersWithTranslationsRow
	for rows.Next() {
		var i GetMeasurementCharactersWithTranslationsRow
		if err := rows.Scan(
			&i.Ref,
			&i.Path,
			&i.Name,
			&i.Details,
			&i.UnitRef,
			&i.NameTr1,
			&i.NameTr2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSummaryDescriptors = `-- name: GetSummaryDescriptors :many
select doc.Ref, doc.Path, doc.Name, tr1.name name_tr1, tr2.name name_tr2, s.Color from Taxon_Description descriptor
inner join Document doc on doc.Ref = descriptor.Description_Ref
inner join State s on s.Document_Ref = descriptor.Description_Ref
left join Document_Translation tr1 on doc.Ref = tr1.Document_Ref and tr1.Lang_Ref = "EN"
left join Document_Translation tr2 on doc.Ref = tr2.Document_Ref and tr2.Lang_Ref = "CN"
where descriptor.Taxon_Ref = ?
order by doc.Path asc, doc.Doc_Order asc
`

type GetSummaryDescriptorsRow struct {
	Ref     string
	Path    string
	Name    string
	NameTr1 sql.NullString
	NameTr2 sql.NullString
	Color   sql.NullString
}

func (q *Queries) GetSummaryDescriptors(ctx context.Context, taxonRef string) ([]GetSummaryDescriptorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSummaryDescriptors, taxonRef)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSummaryDescriptorsRow
	for rows.Next() {
		var i GetSummaryDescriptorsRow
		if err := rows.Scan(
			&i.Ref,
			&i.Path,
			&i.Name,
			&i.NameTr1,
			&i.NameTr2,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaxonBookInfo = `-- name: GetTaxonBookInfo :many
select doc.Ref, doc.Name, info.Fasc, info.Page, info.Details from Taxon_Book_Info info
inner join Document doc on doc.Ref = info.Book_Ref
where info.Taxon_Ref = ?
order by doc.Name
`

type GetTaxonBookInfoRow struct {
	Ref     string
	Name    string
	Fasc    sql.NullInt64
	Page    sql.NullInt64
	Details sql.NullString
}

func (q *Queries) GetTaxonBookInfo(ctx context.Context, taxonRef string) ([]GetTaxonBookInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaxonBookInfo, taxonRef)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTaxonBookInfoRow
	for rows.Next() {
		var i GetTaxonBookInfoRow
		if err := rows.Scan(
			&i.Ref,
			&i.Name,
			&i.Fasc,
			&i.Page,
			&i.Details,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaxonInfo = `-- name: GetTaxonInfo :one
select t.document_ref, t.author, t.website, t.meaning, t.herbarium_no, t.herbarium_picture, t.fasc, t.page, doc.ref, doc.path, doc.doc_order, doc.name, doc.details, tr1.name name_v, tr2.name name_cn from Taxon t
inner join Document doc on doc.Ref = t.Document_Ref
left join Document_Translation tr1 on doc.Ref = tr1.Document_Ref and tr1.Lang_Ref = "V"
left join Document_Translation tr2 on doc.Ref = tr2.Document_Ref and tr2.Lang_Ref = "CN"
where t.Document_Ref = ?1
`

type GetTaxonInfoRow struct {
	DocumentRef      string
	Author           string
	Website          sql.NullString
	Meaning          sql.NullString
	HerbariumNo      sql.NullString
	HerbariumPicture sql.NullString
	Fasc             sql.NullInt64
	Page             sql.NullInt64
	Ref              string
	Path             string
	DocOrder         int64
	Name             string
	Details          sql.NullString
	NameV            sql.NullString
	NameCn           sql.NullString
}

func (q *Queries) GetTaxonInfo(ctx context.Context, ref string) (GetTaxonInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getTaxonInfo, ref)
	var i GetTaxonInfoRow
	err := row.Scan(
		&i.DocumentRef,
		&i.Author,
		&i.Website,
		&i.Meaning,
		&i.HerbariumNo,
		&i.HerbariumPicture,
		&i.Fasc,
		&i.Page,
		&i.Ref,
		&i.Path,
		&i.DocOrder,
		&i.Name,
		&i.Details,
		&i.NameV,
		&i.NameCn,
	)
	return i, err
}

const getTaxonStateDescriptors = `-- name: GetTaxonStateDescriptors :many
select doc.Ref, doc.Path from Taxon_Description descriptor
inner join Document doc on doc.Ref = descriptor.Description_Ref
where descriptor.Taxon_Ref = ?
order by doc.Path asc, doc.Doc_Order asc
`

type GetTaxonStateDescriptorsRow struct {
	Ref  string
	Path string
}

func (q *Queries) GetTaxonStateDescriptors(ctx context.Context, taxonRef string) ([]GetTaxonStateDescriptorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaxonStateDescriptors, taxonRef)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTaxonStateDescriptorsRow
	for rows.Next() {
		var i GetTaxonStateDescriptorsRow
		if err := rows.Scan(&i.Ref, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBook = `-- name: InsertBook :execresult
insert into
    Book (Document_Ref, ISBN)
values
    (?, ?)
`

type InsertBookParams struct {
	DocumentRef string
	Isbn        sql.NullString
}

func (q *Queries) InsertBook(ctx context.Context, arg InsertBookParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertBook, arg.DocumentRef, arg.Isbn)
}

const insertCategoricalCharacter = `-- name: InsertCategoricalCharacter :execresult
insert into
    Categorical_Character (Document_Ref, Color)
values
    (?, ?)
`

type InsertCategoricalCharacterParams struct {
	DocumentRef string
	Color       sql.NullString
}

func (q *Queries) InsertCategoricalCharacter(ctx context.Context, arg InsertCategoricalCharacterParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertCategoricalCharacter, arg.DocumentRef, arg.Color)
}

const insertDescriptorVisibilityInapplicable = `-- name: InsertDescriptorVisibilityInapplicable :execresult
insert into Descriptor_Visibility_Inapplicable (
    Descriptor_Ref, 
    Inapplicable_Descriptor_Ref)
values
    (?, ?)
`

type InsertDescriptorVisibilityInapplicableParams struct {
	DescriptorRef             string
	InapplicableDescriptorRef string
}

func (q *Queries) InsertDescriptorVisibilityInapplicable(ctx context.Context, arg InsertDescriptorVisibilityInapplicableParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertDescriptorVisibilityInapplicable, arg.DescriptorRef, arg.InapplicableDescriptorRef)
}

const insertDescriptorVisibilityRequirement = `-- name: InsertDescriptorVisibilityRequirement :execresult
insert into Descriptor_Visibility_Requirement (
    Descriptor_Ref, 
    Required_Descriptor_Ref)
values
    (?, ?)
`

type InsertDescriptorVisibilityRequirementParams struct {
	DescriptorRef         string
	RequiredDescriptorRef string
}

func (q *Queries) InsertDescriptorVisibilityRequirement(ctx context.Context, arg InsertDescriptorVisibilityRequirementParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertDescriptorVisibilityRequirement, arg.DescriptorRef, arg.RequiredDescriptorRef)
}

const insertDocument = `-- name: InsertDocument :execresult
insert into Document (Ref, Path, Doc_Order, Name, Details)
    values (?, ?, ?, ?, ?)
`

type InsertDocumentParams struct {
	Ref      string
	Path     string
	DocOrder int64
	Name     string
	Details  sql.NullString
}

func (q *Queries) InsertDocument(ctx context.Context, arg InsertDocumentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertDocument,
		arg.Ref,
		arg.Path,
		arg.DocOrder,
		arg.Name,
		arg.Details,
	)
}

const insertDocumentAttachment = `-- name: InsertDocumentAttachment :execresult
insert into Document_Attachment (
    Document_Ref, 
    Attachment_Index, 
    Source, 
    Path,
    Path_Small,
    Path_Medium,
    Path_Big)
values
    (?, ?, ?, ?, ?, ?, ?)
`

type InsertDocumentAttachmentParams struct {
	DocumentRef     string
	AttachmentIndex int64
	Source          string
	Path            string
	PathSmall       string
	PathMedium      string
	PathBig         string
}

func (q *Queries) InsertDocumentAttachment(ctx context.Context, arg InsertDocumentAttachmentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertDocumentAttachment,
		arg.DocumentRef,
		arg.AttachmentIndex,
		arg.Source,
		arg.Path,
		arg.PathSmall,
		arg.PathMedium,
		arg.PathBig,
	)
}

const insertDocumentTranslation = `-- name: InsertDocumentTranslation :execresult
insert into Document_Translation (
    Document_Ref, 
    Lang_Ref, 
    Name, 
    Details)
values
    (?, ?, ?, ?)
`

type InsertDocumentTranslationParams struct {
	DocumentRef string
	LangRef     string
	Name        string
	Details     sql.NullString
}

func (q *Queries) InsertDocumentTranslation(ctx context.Context, arg InsertDocumentTranslationParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertDocumentTranslation,
		arg.DocumentRef,
		arg.LangRef,
		arg.Name,
		arg.Details,
	)
}

const insertGeographicalCharacter = `-- name: InsertGeographicalCharacter :execresult
insert into Geographical_Character (
    Document_Ref,
    Map_Ref,
	Color)
values
    (?, ?, ?)
`

type InsertGeographicalCharacterParams struct {
	DocumentRef string
	MapRef      string
	Color       sql.NullString
}

func (q *Queries) InsertGeographicalCharacter(ctx context.Context, arg InsertGeographicalCharacterParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertGeographicalCharacter, arg.DocumentRef, arg.MapRef, arg.Color)
}

const insertGeographicalMap = `-- name: InsertGeographicalMap :execresult
insert into Geographical_Map (
    Document_Ref,
    Place_Ref,
    Map_File,
    Map_File_Feature_Name) 
values 
    (?, ?, ?, ?)
`

type InsertGeographicalMapParams struct {
	DocumentRef        string
	PlaceRef           string
	MapFile            string
	MapFileFeatureName string
}

func (q *Queries) InsertGeographicalMap(ctx context.Context, arg InsertGeographicalMapParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertGeographicalMap,
		arg.DocumentRef,
		arg.PlaceRef,
		arg.MapFile,
		arg.MapFileFeatureName,
	)
}

const insertGeographicalPlace = `-- name: InsertGeographicalPlace :execresult
insert into Geographical_Place (
    Document_Ref,
    Latitude,
    Longitude,
    Scale)
values
    (?, ?, ?, ?)
`

type InsertGeographicalPlaceParams struct {
	DocumentRef string
	Latitude    float64
	Longitude   float64
	Scale       int64
}

func (q *Queries) InsertGeographicalPlace(ctx context.Context, arg InsertGeographicalPlaceParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertGeographicalPlace,
		arg.DocumentRef,
		arg.Latitude,
		arg.Longitude,
		arg.Scale,
	)
}

const insertLang = `-- name: InsertLang :execresult
insert into
    Lang (Ref, Name)
values
    (?, ?)
`

type InsertLangParams struct {
	Ref  string
	Name string
}

func (q *Queries) InsertLang(ctx context.Context, arg InsertLangParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertLang, arg.Ref, arg.Name)
}

const insertMeasurementCharacter = `-- name: InsertMeasurementCharacter :execresult
insert into
    Measurement_Character (Document_Ref, Color, Unit_Ref)
values
    (?, ?, ?)
`

type InsertMeasurementCharacterParams struct {
	DocumentRef string
	Color       sql.NullString
	UnitRef     sql.NullString
}

func (q *Queries) InsertMeasurementCharacter(ctx context.Context, arg InsertMeasurementCharacterParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertMeasurementCharacter, arg.DocumentRef, arg.Color, arg.UnitRef)
}

const insertPeriodicCharacter = `-- name: InsertPeriodicCharacter :execresult
insert into Periodic_Character (
    Document_Ref, 
    Periodic_Category_Ref, 
    Color)
values 
    (?, ?, ?)
`

type InsertPeriodicCharacterParams struct {
	DocumentRef         string
	PeriodicCategoryRef string
	Color               sql.NullString
}

func (q *Queries) InsertPeriodicCharacter(ctx context.Context, arg InsertPeriodicCharacterParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertPeriodicCharacter, arg.DocumentRef, arg.PeriodicCategoryRef, arg.Color)
}

const insertState = `-- name: InsertState :execresult
insert into
    State (Document_Ref, Color)
values
    (?, ?)
`

type InsertStateParams struct {
	DocumentRef string
	Color       sql.NullString
}

func (q *Queries) InsertState(ctx context.Context, arg InsertStateParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertState, arg.DocumentRef, arg.Color)
}

const insertTaxon = `-- name: InsertTaxon :execresult
insert into Taxon (
    Document_Ref,
    Author,
    Website,
	Meaning,
    Herbarium_No,
    Herbarium_Picture,
    Fasc,
    Page)
values (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertTaxonParams struct {
	DocumentRef      string
	Author           string
	Website          sql.NullString
	Meaning          sql.NullString
	HerbariumNo      sql.NullString
	HerbariumPicture sql.NullString
	Fasc             sql.NullInt64
	Page             sql.NullInt64
}

func (q *Queries) InsertTaxon(ctx context.Context, arg InsertTaxonParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertTaxon,
		arg.DocumentRef,
		arg.Author,
		arg.Website,
		arg.Meaning,
		arg.HerbariumNo,
		arg.HerbariumPicture,
		arg.Fasc,
		arg.Page,
	)
}

const insertTaxonBookInfo = `-- name: InsertTaxonBookInfo :execresult
insert into Taxon_Book_Info (
    Taxon_Ref,
	Book_Ref,
	Fasc,
	Page,
    Details) 
values (?, ?, ?, ?, ?)
`

type InsertTaxonBookInfoParams struct {
	TaxonRef string
	BookRef  string
	Fasc     sql.NullInt64
	Page     sql.NullInt64
	Details  sql.NullString
}

func (q *Queries) InsertTaxonBookInfo(ctx context.Context, arg InsertTaxonBookInfoParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertTaxonBookInfo,
		arg.TaxonRef,
		arg.BookRef,
		arg.Fasc,
		arg.Page,
		arg.Details,
	)
}

const insertTaxonDescription = `-- name: InsertTaxonDescription :execresult
insert into Taxon_Description (
    Taxon_Ref,
	Description_Ref)
values (?, ?)
`

type InsertTaxonDescriptionParams struct {
	TaxonRef       string
	DescriptionRef string
}

func (q *Queries) InsertTaxonDescription(ctx context.Context, arg InsertTaxonDescriptionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertTaxonDescription, arg.TaxonRef, arg.DescriptionRef)
}

const insertTaxonMeasurement = `-- name: InsertTaxonMeasurement :execresult
insert into Taxon_Measurement (
    Taxon_Ref ,
	Character_Ref,
	Minimum,
	Maximum) 
values (?, ?, ?, ?)
`

type InsertTaxonMeasurementParams struct {
	TaxonRef     string
	CharacterRef string
	Minimum      sql.NullFloat64
	Maximum      sql.NullFloat64
}

func (q *Queries) InsertTaxonMeasurement(ctx context.Context, arg InsertTaxonMeasurementParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertTaxonMeasurement,
		arg.TaxonRef,
		arg.CharacterRef,
		arg.Minimum,
		arg.Maximum,
	)
}

const insertTaxonSpecimenLocation = `-- name: InsertTaxonSpecimenLocation :execresult
insert into Taxon_Specimen_Location (
    Taxon_Ref,
    Specimen_Index,
    Latitude,
    Longitude) 
values (?, ?, ?, ?)
`

type InsertTaxonSpecimenLocationParams struct {
	TaxonRef      string
	SpecimenIndex int64
	Latitude      float64
	Longitude     float64
}

func (q *Queries) InsertTaxonSpecimenLocation(ctx context.Context, arg InsertTaxonSpecimenLocationParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertTaxonSpecimenLocation,
		arg.TaxonRef,
		arg.SpecimenIndex,
		arg.Latitude,
		arg.Longitude,
	)
}

const insertUnit = `-- name: InsertUnit :execresult
insert into
    Unit (Ref, Base_Unit_Ref, To_Base_Unit_Factor)
values
    (?, ?, ?)
`

type InsertUnitParams struct {
	Ref              string
	BaseUnitRef      sql.NullString
	ToBaseUnitFactor sql.NullFloat64
}

func (q *Queries) InsertUnit(ctx context.Context, arg InsertUnitParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertUnit, arg.Ref, arg.BaseUnitRef, arg.ToBaseUnitFactor)
}

const listLangs = `-- name: ListLangs :many
select lang.ref, lang.name from Lang lang
`

func (q *Queries) ListLangs(ctx context.Context) ([]Lang, error) {
	rows, err := q.db.QueryContext(ctx, listLangs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Lang
	for rows.Next() {
		var i Lang
		if err := rows.Scan(&i.Ref, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
